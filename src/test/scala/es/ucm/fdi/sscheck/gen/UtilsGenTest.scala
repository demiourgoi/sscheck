package es.ucm.fdi.sscheck.gen

import org.scalacheck.{Properties, Gen}
import org.scalacheck.Arbitrary.arbitrary
import org.scalacheck.Prop.{forAll, exists, BooleanOperators}
import Buildables.buildableSeq

object UtilsGenTest extends Properties("UtilsGenTest test") {  
  property("""containerOfNtoM is able to generate sequences of 
		  string with size between N and M strings for both N and M >= 0""")  = 
    forAll (Gen.choose(0, 10), Gen.choose(0, 10)) { (n : Int, m : Int) => 
      val g = UtilsGen.containerOfNtoM(n, m, arbitrary[String]) : Gen[Seq[String]]
      forAll (g) { ( xs : Seq[String]) =>   
       xs.length >= n && xs.length <= m 
      }
    }
  
  property("repN respects its lenght constraints") = 
    forAll (Gen.choose(0, 10), Gen.choose(0, 10)) { (n : Int, xsLen : Int) => 
      val g = UtilsGen.repN(n, Gen.listOfN(xsLen, Gen.alphaStr)) 
      forAll (g) { (xs : Seq[String])  =>
        xs.length == xsLen * n
      }
    }
  
  property("repNtoM respects its lenght constraints") = 
    forAll (Gen.choose(0, 10), Gen.choose(0, 10), Gen.choose(0, 10)) { (n : Int, m : Int, xsLen : Int) => 
      val g = UtilsGen.repNtoM(n, m, Gen.listOfN(xsLen, arbitrary[String])) 
      forAll (g) { (xs : Seq[String])  =>
        val xsLenObs = xs.length
        xsLenObs >= xsLen * n && xsLen * n <= xsLen * m 
      }
    }   
    
  property("""concSeq returns the result of concatenating the sequences 
generated by its arguments""") = {
    // In order for Prop.exists to be effective, we use a small domain.  
    // For all the lengths considered: this is very weak because very little lengths
    // are considered but it's better than nothing. 
    forAll (Gen.choose(0, 2)) { (xsLen : Int) =>
      // we consider two generators for lists of elements with that size
      val (gxs1, gxs2) = (Gen.listOfN(xsLen, Gen.choose(1, 3)), Gen.listOfN(xsLen, Gen.choose(4, 6)))
      // val g = UtilsGen.concSeq(gxs1, gxs2)
      forAll (UtilsGen.concSeq(gxs1, gxs2)) { (xs : Seq[Int]) =>
        // Prop.exists is not overloaded to support several generators
        // so we have to use zip
        exists (Gen.zip(gxs1, gxs2)) { (xs12 : (List[Int], List[Int])) =>
          xs == xs12._1 ++ xs12._2
        }
      }
    }    
  } 
}