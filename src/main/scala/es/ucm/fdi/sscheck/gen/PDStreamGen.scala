package es.ucm.fdi.sscheck.gen

import org.scalacheck.Gen
import org.scalacheck.Arbitrary
import org.scalacheck.Arbitrary.arbitrary
import org.scalacheck.Shrink
import org.scalacheck.Shrink.shrink
import BatchGen.now  
import scala.language.implicitConversions
import es.ucm.fdi.sscheck.prop.tl.Timeout

/** Implicit conversions removed from BatchGen companion. This is needed
 *  because we cannot populate the name space with standard names for HO generators
 *  like of() or ofN(), but we also want to have these implicit conversions available
 */
object PDStreamGenConversions {
  implicit def genDStream2DStreamGen[A](dsg : Gen[PDStream[A]]) : PDStreamGen[A] = PDStreamGen(dsg)
    
  implicit def dstreamGen2batchSeqGen[A](gs : Gen[PDStream[A]]) : Gen[Seq[Batch[A]]] = gs.map(_.toSeq)
  implicit def batchSeqGen2dstreamGen[A](gs : Gen[Seq[Batch[A]]]) : Gen[PDStream[A]] = gs.map(PDStream(_:_*)) 
}

/**
 * All the temporal generators defined in this object are sized generators, but the size parameters
 * only affects the number of batches in the output PDStream, not the size of the batches. 
 * The size of the batches can be changed by using Gen.resize in the definition of the batch
 * generator that is passed to these HO generators
 * 
 * On the other hand for generators of arbitrary PDStreams like Gen.resize(5, arbitrary[DStream[Int]])
 * Gen.resize has effect, both in the number of batches and in the size of the batches, as those
 * arbitrary instances are based on arbitrary for lists
 * 
 *  TODO  That should be tested
  // by using Gen.resize(5, TLGen.always(Batch(List(0, 1)))) (constant batch size)
  // and then in Gen.resize(3, TLGen.always(BatchGen.ofNtoM(1, 5, Gen.choose(0, 3))))
  // the point is that we always have 3 batches, but Gen.resize doesn't affect the batch
  // size but only the number of batches
  // 
 * 
 * */
object PDStreamGen {
  import PDStreamGenConversions._ 
  
  def apply[A](dsg : Gen[PDStream[A]]) : PDStreamGen[A] = new PDStreamGen(dsg)
    
  /** Arbitrary generator for DStream. Only works if an Arbitrary for Batch is also present. 
   *  Note this hasn't been automatically derived from Buildables.buildableDStreamFromBatch
   *  for the same reason Gen.buildableOf has to be used with DStream instead of Gen.containerOf
   * */
  implicit def arbDStream[A](implicit arbBatch : Arbitrary[Batch[A]]) : Arbitrary[PDStream[A]] = 
    Arbitrary(PDStreamGen.of(arbitrary[Batch[A]]))
   
   /*  This makes no sense for temporal generators, see third comment 
    *  at issue #10 
   */
//  /** Shrink function for DStream 
//   * */
//  implicit def shrinkDStream[A] : Shrink[PDStream[A]] = Shrink(pdstream => 
//    // unwrap the underlying Seq, shrink the Seq, and rewrap
//    shrink(pdstream.toSeq).map(PDStream(_:_*))
//  )
  
  /** @return a generator of DStream that generates its batches from bg
   * */
  def of[T](bg : => Gen[Batch[T]]) : Gen[PDStream[T]] = {
    import Buildables.buildablePDStreamFromBatch
    Gen.buildableOf[PDStream[T], Batch[T]](bg)
  }
  /** @return a generator of DStream that generates its batches from bg
   * */
  def ofN[T](n : Int, bg : Gen[Batch[T]]) : Gen[PDStream[T]] = {
    import Buildables.buildablePDStreamFromBatch
    Gen.buildableOfN[PDStream[T], Batch[T]](n, bg)
  }
  /** @return a generator of DStream that generates its batches from bg
   * */
  def ofNtoM[T](n : Int, m : Int, bg : Gen[Batch[T]]) : Gen[PDStream[T]] = {
    import Buildables.buildablePDStreamFromBatch
    UtilsGen.buildableOfNtoM[PDStream[T], Batch[T]](n, m, bg)
  }
  
  /** @return a generator for the batch-by-batch concatenation of the PDStreams 
  *  generated by gs1 and gs2. Note we fill either PDStreams with empty batches 
  *  This implies PDStreams are implicitly treated as they where infinitely extended 
  *  with empty batches  
  */
  def dstreamUnion[A](gs1 : Gen[PDStream[A]], gs2 : Gen[PDStream[A]]) : Gen[PDStream[A]] = {
    for {
      xs1 <- gs1
      xs2 <- gs2
    } yield xs1 #+ xs2 
  }
  
  /** @return a dstream generator that has an empty batch followed by the batches
   *  from dsg
   * */
  def next[A](dsg : Gen[PDStream[A]]) : Gen[PDStream[A]] = {
    laterN(1, dsg)
  }
  
  /** @return a dstream generator that has n empty batches followed by the batches
   *  from dsg
   * */
  def laterN[A](n : Int, dsg : Gen[PDStream[A]]) : Gen[PDStream[A]] = 
    for {
      ds <- dsg
      blanks = Seq.fill(n)(Batch.empty : Batch[A])
    } yield blanks ++ ds
  
  /**
   * This is sized generator where the size acts like the timeout, so
   * - with size <= 0 returns the empty PDStream, as no word can 
   * succeed with a timeout of 0
   * - with size 1 returns a PDStream generated by dsg2
   * - otherwise dsg2 happens after between 0 and size-1 instants
   * */
  def until[A](dsg1 : Gen[PDStream[A]], dsg2 : Gen[PDStream[A]]) : Gen[PDStream[A]] =
    Gen.sized { size =>
      if (size <= 0)
        Gen.const(PDStream.empty)
      else if (size == 1)
        dsg2
      else 
        for {
          proofOffset <- Gen.choose(0, size-1)
          prefix <- always(dsg1, Timeout(proofOffset)) 
          dsg2Proof <- laterN(proofOffset, dsg2)
        } yield prefix #+ dsg2Proof
    }  
  
  def until[A](dsg1 : Gen[PDStream[A]], dsg2 : Gen[PDStream[A]], t : Timeout) : Gen[PDStream[A]] =
    Gen.resize(t.instants, until(dsg1, dsg2))
    
  /** Sized generator where  the size acts like the timeout, so
   *  - with size <= 0 returns the empty PDStream
   *  - otherwise dsg happens at some moment between 0 and size instants
   */
  def eventually[A](dsg : Gen[PDStream[A]]) : Gen[PDStream[A]] =
    Gen.sized { size =>
      if (size <0)
        Gen.const(PDStream.empty)
      else
        PDStreamGen.ofNtoM(0, size -1, Batch.empty : Batch[A]) ++ dsg 
    }
  def eventually[A](dsg : Gen[PDStream[A]], t : Timeout) : Gen[PDStream[A]] = 
    Gen.resize(t.instants, eventually(dsg))
  
  /** Sized generator where the size acts like the timeout, so
   *  - with size <= 0 returns the empty PDStream
   *  - otherwise dsg happens size times from now
   */
  def always[A](dsg : Gen[PDStream[A]]) : Gen[PDStream[A]] =
    Gen.sized { size =>
      if (size <= 0) // supporting size == 0 is needed by the calls to always from until and release 
        Gen.const(PDStream.empty)
      else 
        (for {
          offset <- 0 until size
        } yield laterN(offset, dsg) 
        )
        .reduce(dstreamUnion(_,_))
    }
  def always[A](dsg : Gen[PDStream[A]], t : Timeout) : Gen[PDStream[A]] = 
    Gen.resize(t.instants, always(dsg))
  
  /** 
   *  Generator for the weak version of LTL release operator: either dsg2
   *  happens forever, or it happens until dsg1 happens, including the
   *  moment when dsg1 happens  
   *  
   *  This is a sized generator where the size acts like the timeout, so
   *   - with size <= 0 returns the empty PDStream
   *   - otherwise, if dsg1 happens then it happens after between 0 and size-1 instants 
   * */
  def release[A](dsg1 : Gen[PDStream[A]], dsg2 : Gen[PDStream[A]]) : Gen[PDStream[A]] = 
    Gen.sized { size =>
      if (size <= 0)
        Gen.const(PDStream.empty)
      else if (size == 1) for {
        isReleased <- arbitrary[Boolean]
        proof <- if (isReleased) (dsg1 + dsg2) else dsg2
      } yield proof
      else for {
          isReleased <- arbitrary[Boolean]
          ds <- if (!isReleased)
                  always(dsg2, Timeout(size))
                else for {
                  proofOffset <- Gen.choose(0, size-1) 
                  prefix <- always(dsg2, Timeout(proofOffset))
                  ending <- laterN(proofOffset, dsg1 + dsg2)
                } yield prefix #+ ending
      } yield ds
    }  
  
  def release[A](dsg1 : Gen[PDStream[A]], dsg2 : Gen[PDStream[A]], t : Timeout) : Gen[PDStream[A]] =
    Gen.resize(t.instants, release(dsg1, dsg2)) 
}

class PDStreamGen[A](self : Gen[PDStream[A]]) {
  import PDStreamGen._
  import PDStreamGenConversions._
  /** Returns the generator that results from concatenating the sequences
   *  generated by the generator wrapped by this, and other 
   * */
  def ++(other : Gen[PDStream[A]]) : Gen[PDStream[A]] = UtilsGen.concSeq(self, other)
  
  /** @return a generator for the batch-by-batch concatenation of the PDStreams 
  * generated by the generator wrapped by this, and other 
  * Note we fill either PDStreams with empty batches. This implies PDStreams 
  * are implicitly treated as they where infinitely extended with empty batches  
  */
  def +(other : Gen[PDStream[A]]) : Gen[PDStream[A]] = dstreamUnion(self, other)
  
  def next : Gen[PDStream[A]] = PDStreamGen.next(self)
  def laterN(n : Int) : Gen[PDStream[A]] = PDStreamGen.laterN(n, self)
  def eventually : Gen[PDStream[A]] = PDStreamGen.eventually(self)
  def until(other : Gen[PDStream[A]]) : Gen[PDStream[A]] = PDStreamGen.until(self, other)
  def always : Gen[PDStream[A]] = PDStreamGen.always(self)
  def release(other : Gen[PDStream[A]]) : Gen[PDStream[A]] = PDStreamGen.release(self, other)
}