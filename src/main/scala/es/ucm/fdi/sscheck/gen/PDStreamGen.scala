package es.ucm.fdi.sscheck.gen

import org.scalacheck.Gen
import org.scalacheck.Arbitrary
import org.scalacheck.Arbitrary.arbitrary
import org.scalacheck.Shrink
import org.scalacheck.Shrink.shrink
import BatchGen.now  
import scala.language.implicitConversions

/**
 * All the temporal generators defined in this object are sized generators, but the size parameters
 * only affects the number of batches in the output PDStream, not the size of the batches. 
 * The size of the batches can be changed by using Gen.resize in the definition of the batch
 * generator that is passed to these HO generators
 * 
 * On the other hand for generators of arbitrary PDStreams like Gen.resize(5, arbitrary[DStream[Int]])
 * Gen.resize has effect, both in the number of batches and in the size of the batches, as those
 * arbitrary instances are based on arbitrary for lists
 * 
 *  TODO  That should be tested
  // by using Gen.resize(5, TLGen.always(Batch(List(0, 1)))) (constant batch size)
  // and then in Gen.resize(3, TLGen.always(BatchGen.ofNtoM(1, 5, Gen.choose(0, 3))))
  // the point is that we always have 3 batches, but Gen.resize doesn't affect the batch
  // size but only the number of batches
  // 
 *
 * TODO tests for all of this
 * TODO make some example with the assertions from expected and observed for 
 * Seq[Seq[A]], use map on the generated DStreams and batch as those are Seq, 
 * check if comprehensions work or we have to implement something 
 * */
object PDStreamGen {
  def apply[A](dsg : Gen[PDStream[A]]) : PDStreamGen[A] = new PDStreamGen(dsg)
  implicit def genDStream2DStreamGen[A](dsg : Gen[PDStream[A]]) : PDStreamGen[A] = PDStreamGen(dsg)
    
  implicit def dstreamGen2batchSeqGen[A](gs : Gen[PDStream[A]]) : Gen[Seq[Batch[A]]] = gs.map(_.toSeq)
  implicit def batchSeqGen2dstreamGen[A](gs : Gen[Seq[Batch[A]]]) : Gen[PDStream[A]] = gs.map(PDStream(_:_*))
    
  /** Arbitrary generator for DStream. Only works if an Arbitrary for Batch is also present. 
   *  Note this hasn't been automatically derived from Buildables.buildableDStreamFromBatch
   *  for the same reason Gen.buildableOf has to be used with DStream instead of Gen.containerOf
   * */
  implicit def arbDStream[A](implicit arbBatch : Arbitrary[Batch[A]]) : Arbitrary[PDStream[A]] = 
    Arbitrary(PDStreamGen.of(arbitrary[Batch[A]]))
   
  /** Shrink function for DStream 
   * */
  implicit def shrinkDStream[A] : Shrink[PDStream[A]] = Shrink(pdstream => 
    // unwrap the underlying Seq, shrink the Seq, and rewrap
    shrink(pdstream.toSeq).map(PDStream(_:_*))
  )  
  
  /** @returns a generator of DStream that generates its batches from bg
   * */
  def of[T](bg : => Gen[Batch[T]]) : Gen[PDStream[T]] = {
    import Buildables.buildablePDStreamFromBatch
    Gen.buildableOf[PDStream[T], Batch[T]](bg)
  }
  /** @returns a generator of DStream that generates its batches from bg
   * */
  def ofN[T](n : Int, bg : Gen[Batch[T]]) : Gen[PDStream[T]] = {
    import Buildables.buildablePDStreamFromBatch
    Gen.buildableOfN[PDStream[T], Batch[T]](n, bg)
  }
  /** @returns a generator of DStream that generates its batches from bg
   * */
  def ofNtoM[T](n : Int, m : Int, bg : Gen[Batch[T]]) : Gen[PDStream[T]] = {
    import Buildables.buildablePDStreamFromBatch
    UtilsGen.buildableOfNtoM[PDStream[T], Batch[T]](n, m, bg)
  }
  
  /** @return a generator for the batch-by-batch concatenation of the PDStreams 
  *  generated by gs1 and gs2. Note we fill either PDStreams with empty batches 
  *  This implies PDStreams are implicitly treated as they where infinitely extended 
  *  with empty batches  
  */
  def dstreamUnion[A](gs1 : Gen[PDStream[A]], gs2 : Gen[PDStream[A]]) : Gen[PDStream[A]] = {
    for {
      xs1 <- gs1
      xs2 <- gs2
    } yield xs1 #+ xs2 
  }
  
  /** @return a dstream generator that has an empty batch followed by the batches
   *  from dsg
   * */
  def next[A](dsg : Gen[PDStream[A]]) : Gen[PDStream[A]] = {
    // now(Batch.empty : Batch[A]) ++ dsg
    laterN(1, dsg)
  }
  
  /** @return a dstream generator that has n empty batches followed by the batches
   *  from dsg
   * */
  def laterN[A](n : Int, dsg : Gen[PDStream[A]]) : Gen[PDStream[A]] = {
    dsg.map(Seq.fill(n)(Batch.empty : Batch[A]) ++ _)
  }
  
  /**
   * Example: 
   * 
   * Gen.resize(4, {
   * val g1 : Gen[DStream[Int]] = DStream(Batch(0), Batch(1))
   * g1 until DStream(Batch(2), Batch(3))
   *  }
   * ).sample    //> res13: Option[es.ucm.fdi.sscheck.DStream[Int]] = Some(DStream(Batch(0), Bat
   *             //| ch(1, 0), Batch(1, 2), Batch(3)))
   * 
   * Note: the following implementation is wrong, because in the second batch neither
   * DStream(Batch(0), Batch(1)) happens, because 1 doesn't belong to that batch, nor
   * DStream(Batch(2)) happens, because 2 doesn't belong to that batch
   *  
   * Gen.resize(4,
   * 	DStreamGen.until(
   *	  DStream(Batch(0), Batch(1)),
   * 	  DStream(Batch(2))
   * 	)
   * ).sample      //> res11: Option[es.ucm.fdi.sscheck.DStream[Int]] = Some(DStream(Batch(0), Bat
   *               //| ch(1), Batch(0), Batch(1), Batch(0), Batch(1), Batch(2)))
   * 
   * */
  def until[A](dsg1 : Gen[PDStream[A]], dsg2 : Gen[PDStream[A]]) : Gen[PDStream[A]] =
    /*
    This implementation doesn't grant a strong until for big streams, because
    we are not granted that dsg2 will be eventually reached
    Gen.sized { size =>
      if (size <= 1) 
        dsg2
      else
        for {
          nowD <- dsg1
          laterDs <- next(Gen.resize(size - 1, until(dsg1, dsg2)))
        } yield nowD #+ laterDs
    } 
    On the other hand the implementation below passes the tests
    * */   
    Gen.sized { size => 
       for {
         // this works because always in fact generates a finite prefix of the real always
         prefix <- Gen.resize(size - 1, always(dsg1))
         dsg2Proof <- dsg2
       } yield {
         // note +1 is used so dsg2 only happens after dsg1
         val dsg2DStream  = Seq.fill(prefix.length - dsg2Proof.length + 1)(Batch.empty : Batch[A]) ++ dsg2Proof
         prefix #+ dsg2DStream 
       }
    }
    
  def eventually[A](bg : Gen[PDStream[A]]) : Gen[PDStream[A]] =
    Gen.sized { size =>
      PDStreamGen.ofNtoM(0, size -1, Batch.empty : Batch[A]) ++ bg 
    }
  
  /**
   * Example: an always of an until must ensure a new until instance is generated at
   * each batch / moment 
   * 
   val alwaysS2 =
    always(
      TLGen.until(Batch(0), Batch(1))
    )            
                 
   Gen.resize(6, alwaysS2).sample        //> res38: Option[es.ucm.fdi.sscheck.DStream[Int]] = Some(DStream(Batch(0), Bat
                                         //| ch(0, 0), Batch(1, 1, 1), Batch(0), Batch(1, 1), Batch(1)))
   Gen.resize(10, alwaysS2).sample       //> res39: Option[es.ucm.fdi.sscheck.DStream[Int]] = Some(DStream(Batch(0), Bat
                                         //| ch(0, 0), Batch(0, 0, 1), Batch(0, 0, 0), Batch(0, 1, 0, 0), Batch(0, 0, 1,
                                         //|  0), Batch(0, 0, 0, 0), Batch(1, 0, 0, 0, 0), Batch(0, 1, 1, 0, 0), Batch(1
                                         //| , 1, 1, 1)))
   * */
  def always[A](dsg : Gen[PDStream[A]]) : Gen[PDStream[A]] =
    Gen.sized { size =>
      if (size <= 0)
        Gen.const(PDStream.empty)
      else 
        /* note this is not the same as laterDs <- Gen.resize(size - 1, alwaysS(dsg))
         * and then yield nowDs ++ laterDs, because this way a DStream from dsg is
         * started at each moment 
         */
        for {
          nowDs <- dsg
          laterDs <- next(Gen.resize(size - 1, always(dsg)))
        } yield nowDs #+ laterDs
    }
  
  /** 
   *  Generator for the weak version of LTL release operator: either bg2
   *  happens forever, or it happens until bg1 happens, including the
   *  moment when bg1 happens  
   * */
  def release[A](dsg1 : Gen[PDStream[A]], dsg2 : Gen[PDStream[A]]) : Gen[PDStream[A]] = {
    /* The definition of release applied to finite prefixes is the same as "dsg2 happens
     * until either dsg2 happens once more (this is finite), or dsg1 and dsg2 happen" 
     * */
    val tailGen = for {
      isReleased <- arbitrary[Boolean]
      dsg1Proof <- if (isReleased) (dsg1 + dsg2) else dsg2
    } yield dsg1Proof
    until(dsg2, tailGen)
  }
} 

class PDStreamGen[A](self : Gen[PDStream[A]]) {
  import PDStreamGen._
  /** Returns the generator that results from concatenating the sequences
   *  generated by the generator wrapped by this, and other 
   * */
  def ++(other : Gen[PDStream[A]]) : Gen[PDStream[A]] = UtilsGen.concSeq(self, other)
  
  /** @return a generator for the batch-by-batch concatenation of the PDStreams 
  * generated by the generator wrapped by this, and other 
  * Note we fill either PDStreams with empty batches. This implies PDStreams 
  * are implicitly treated as they where infinitely extended with empty batches  
  */
  def +(other : Gen[PDStream[A]]) : Gen[PDStream[A]] = dstreamUnion(self, other)
  
  def next : Gen[PDStream[A]] = PDStreamGen.next(self)
  def laterN(n : Int) : Gen[PDStream[A]] = PDStreamGen.laterN(n, self)
  def eventually : Gen[PDStream[A]] = PDStreamGen.eventually(self)
  def until(other : Gen[PDStream[A]]) : Gen[PDStream[A]] = PDStreamGen.until(self, other)
  def always : Gen[PDStream[A]] = PDStreamGen.always(self)
  def release(other : Gen[PDStream[A]]) : Gen[PDStream[A]] = PDStreamGen.release(self, other)
}